# 设计模式的分类
* 创建型
    * 单例模式、工厂模式（工厂方法和抽象工厂）、建造者模式、原型模式
* 建造型
    * 代理模式、桥接模式、装饰者模式、适配器模式、门面模式、组合模式、享元模式
* 行为型 
    * 观察者模式、模板模式、策略模式、职责链模式、迭代器模式、状态模式、访问者模式、备忘录模式、命令模式、解释器模式、中介模式

# 设计原则
* SOLID 原则 -SRP 单一职责原则
* SOLID 原则 -OCP 开闭原则
* SOLID 原则 -LSP 里式替换原则
* SOLID 原则 -ISP 接口隔离原则
* SOLID 原则 -DIP 依赖倒置原则
* DRY 原则、KISS 原则、YAGNI 原则、LOD 法则

## 单一职责原则
* 不要设计大而全的类，要设计粒度小、功能单一的类
    * 一个类如果有多种功能，那就会增加它被其他类依赖的可能性，增加了耦合

* `如何判断类的职责是否足够单一？`
	* 结合业务场景进行拆分，如果场景比较简单(比如只有展示用户列表)，那很多信息堆在一个类也是可以的。如果场景开始复杂多变，那就要根据业务细分出来，针对一个场景作更细致的划分。
	* 我们可以先写一个粗粒度的类，满足业务需求。随着业务的发展，如果粗粒度的类越来越庞大，代码越来越多，这个时候，我们就可以将这个粗粒度的类，拆分成几个更细粒度的类

* 判断原则
	* `类中的代码行数、函数或属性过多`，会影响代码的可读性和可维护性，我们就需要考虑对类进行拆分；
	* `类依赖的其他类过多，或者依赖类的其他类过多`，不符合高内聚、低耦合的设计思想，我们就需要考虑对类进行拆分；
	* `私有方法过多`，我们就要考虑能否将私有方法独立到新的类中，设置为 public 方法，供更多的类使用，从而提高代码的复用性；
	* `比较难给类起一个合适名字`，很难用一个业务名词概括，或者只能用一些笼统的 Manager、Context 之类的词语来命名，这就说明类的职责定义得可能不够清晰；
	* `类中大量的方法都是集中操作类中的某几个属性`，比如，在 UserInfo 例子中，如果一半的方法都是在操作 address 信息，那就可以考虑将这几个属性和对应的方法拆分出来。

## 开闭原则
* 如何理解“对扩展开放、修改关闭”？
	* 添加一个新的功能应该是，在已有代码基础上扩展代码（新增模块、类、方法等），而非修改已有代码（修改模块、类、方法等）。

* 如何做到“对扩展开放、修改关闭”？
	* 为了尽量写出扩展性好的代码，我们要时刻具备扩展意识、抽象意识、封装意识
	* 我们要将可变部分封装起来，隔离变化，提供抽象化的不可变接口，给上层系统使用。

* `开闭原则的关键在于抽象化。可以为系统定义一个相对较为稳定的抽象层，将不同的实现行为放到具体的实现层中完成。`

* 最常用来提高代码扩展性的方法有：多态、依赖注入、基于接口而非实现编程
* 开闭原则并不是说完全杜绝修改，而是以最小的修改代码的代价来完成新功能的开发。

## 里氏代换原则
* 所有引用基类的地方必须能透明地使用其子类的对象。

* 如何理解“里式替换原则”？
	* 子类对象可以替换程序中父类对象出现的任何地方，并且保证原来程序的逻辑行为不变
	* `多态是面向对象编程的一大特性，也是面向对象编程语言的一种语法。它是一种代码实现的思路。而里式替换是一种设计原则，是用来指导继承关系中子类该如何设计的，子类的设计要保证在替换父类的时候，不改变原有程序的逻辑以及不破坏原有程序的正确性。`

## 接口隔离原则
* 客户端不应该被强迫依赖它不需要的接口。其中的“客户端”，可以理解为接口的调用者或者使用者。

* 在设计微服务或者类库接口的时候，如果部分接口只被部分调用者使用，那我们就需要将这部分接口隔离出来，单独给对应的调用者使用，而不是强迫其他调用者也依赖这部分不会被用到的接口。

* **接口隔离原则与单一职责原则的区别**
	* 单一职责原则针对的是模块、类、接口的设计。接口隔离原则相对于单一职责原则，一方面更侧重于接口的设计，另一方面它的思考角度也是不同的。
	* 接口隔离原则提供了一种判断接口的职责是否单一的标准：通过调用者如何使用接口来间接地判定。如果调用者只使用部分接口或接口的部分功能，那接口的设计就不够职责单一。

## 依赖倒置原则
* 依赖倒转原则：高层模块不应该依赖低层模块，它们都应该依赖抽象。抽象不应该依赖于细节，细节应该依赖于抽象。
    * 主要用来指导框架的设计

* 依赖注入
	* `不通过 new() 的方式在类内部创建依赖类对象，而是将依赖的类对象在外部创建好之后，通过构造函数、函数参数等方式传递（或注入）给类使用。`
	* 通过依赖注入的方式来将依赖的类对象传递进来，这样就提高了代码的扩展性，我们可以灵活地替换依赖的类。

## 合成复用原则
* 优先使用对象组合，而不是通过继承来达到复用的目的。

## 迪米特法则
* 何为“高内聚、松耦合”？
	* “高内聚”用来指导类本身的设计，“松耦合”用来指导类与类之间依赖关系的设计。
	* `高内聚，就是指相近的功能应该放到同一个类中，不相近的功能不要放到同一个类中。`
		* 相近的功能往往会被同时修改，放到同一个类中，修改会比较集中，代码容易维护
	* `松耦合是说，在代码中，类与类之间的依赖关系简单清晰`
		* 两个类有依赖关系，一个类的代码改动不会或者很少导致依赖类的代码改动

# 面向对象
## 理论一：当谈论面向对象的时候，我们到底在谈论什么？
* 面向对象的四大特性：封装、抽象、继承、多态
* 面向对象编程从字面上，按照最简单、最原始的方式来理解，就是将对象或类作为代码组织的基本单元
* 面向对象分析就是要搞清楚做什么，面向对象设计就是要搞清楚怎么做，面向对象编程就是将分析和设计的的结果翻译成代码的过程

## 理论二：封装、抽象、继承、多态分别可以解决哪些编程问题？
* 封装
	* 封装也叫作信息隐藏或者数据访问保护。类通过暴露有限的访问接口，授权外部仅能通过类提供的方式（或者叫函数）来访问内部信息或者数据
	* 访问权限控制：private、public、protected
	* 封装的意义
		* 类仅仅通过有限的方法暴露必要的操作，也能提高类的易用性
		* 如果我们把类属性都暴露给类的调用者，调用者想要正确地操作这些属性，就势必要对业务细节有足够的了解。而这对于调用者来说也是一种负担。相反，如果我们将属性封装起来，暴露少许的几个必要的方法给调用者使用，调用者就不需要了解太多背后的业务细节，用错的概率就减少很多。

* 抽象
	* 封装主要讲的是如何隐藏信息、保护数据，而抽象讲的是如何隐藏方法的具体实现，让调用者只需要关心方法提供了哪些功能，并不需要知道这些功能是如何实现的。
	* `抽象类就实现抽象，但并不代表实现抽象必须用抽象类来实现`，类的方法是通过编程语言中的“函数”这一语法机制来实现的。通过函数包裹具体的实现逻辑，这本身就是一种抽象
	* 抽象的意义
		* 抽象作为一种只关注功能点不关注实现的设计思路，正好帮我们的大脑过滤掉许多非必要的信息。
	* 在定义一个命名的时候也需要有抽象的思维

* 继承
	* 继承是用来表示类之间的 is-a 关系
	* 继承存在的意义
		* `优点：解决代码复用，减少代码的冗余。 缺点：继承层次过深，维护比较困难。`

* 多态
	* 多态是指，子类可以替换父类
	* `可以使用接口类来实现多态特性；也可以使用duck-typing语法，但C++不支持`
	* 定义一个接口类，然后分别定义多个类来继承并实现接口类，最后通过传递不同类型的实现类到相应函数中，实现多态
	* 意义
		* 多态特性能提高代码的可扩展性和复用性

* 多重继承的副作用
	* c++首先引入的多重继承带来了诸如菱形继承一类的问题，而后为了解决这个问题又不得不引入了虚继承这种概念
	* 多重继承会额外引入复杂度

* `封装隐藏属性 抽象隐藏方法 继承支持复用 多态支持扩展`

## 理论三：面向对象相比面向过程有哪些优势？面向过程真的过时了吗？
* 什么是面向过程编程与面向过程编程语言？
	* 面向过程编程也是一种编程范式或编程风格。它以过程（可以理解为方法、函数、操作）作为组织代码的基本单元，以数据（可以理解为成员变量、属性）与方法相分离为最主要的特点。`面向过程风格是一种流程化的编程风格，通过拼接一组顺序执行的方法来操作数据完成一项功能。`
	* 面向过程和面向对象最基本的区别
		* `代码的组织方式不同：面向过程风格的代码被组织成了一组方法集合及其数据结构（struct User），方法和数据结构的定义是分开的。面向对象风格的代码被组织成一组类，方法和数据结构被绑定一起，定义在类中。`

* 面向对象编程相比面向过程编程有哪些优势？
	* OOP 更加能够应对大规模复杂程序的开发
		* 面向对象编程是以类为思考对象。在进行面向对象编程的时候，我们并不是一上来就去思考，如何将复杂的流程拆解为一个一个方法，而是采用曲线救国的策略，`先去思考如何给业务建模，如何将需求翻译为类，如何给类之间建立交互关系，而完成这些工作完全不需要考虑错综复杂的处理流程。当我们有了类的设计之后，然后再像搭积木一样，按照处理流程，将类组装起来形成整个程序。`这种开发模式、思考问题的方式，能让我们在应对复杂程序开发的时候，思路更加清晰。
	* OOP 风格的代码更易复用、易扩展、易维护
	* OOP 语言更加人性化、更加高级、更加智能
		* 进行面向对象编程时候，我们是在思考，如何给业务建模，如何将真实的世界映射为类或者对象，这让我们更加能聚焦到业务本身，而不是思考如何跟机器打交道

* `代码的组织单元:面向对象是类和对象，面向过程是函数和数据`

## 理论四：哪些代码设计看似是面向对象，实际是面向过程的？
* 哪些代码设计看似是面向对象，实际是面向过程的？
	* `滥用 getter、setter 方法`
		* 违背了面向对象的封装特性，将所有属性以及赋值方法都暴露出去，任何人在任何地方都可以调用，提高了项目后期的维护成本
		* 在设计实现类的时候，除非真的需要，否则，尽量不要给属性定义 setter 方法。除此之外，尽管 getter 方法相对 setter 方法要安全些，但是如果返回的是集合容器（比如例子中的 List 容器），也要防范集合内部数据被修改的危险。
	* 滥用全局变量和全局方法
		* 定义一个常量类可能存在的问题
			* 会影响代码的可维护性：查找修改某个常量会变得比较费时，而且会增加提交代码冲突的概率
			* 会增加代码编译的时间
			* 会影响代码的复用性：如果我们要在另一个项目中，复用本项目开发的某个类，而这个类又依赖 Constants 类。即便这个类只依赖 Constants 类中的一小部分常量，我们仍然需要把整个 Constants 类也一并引入，也就引入了很多无关的常量到新的项目中。
		* 改进常量类的思路
			* 将一个常量类拆分成多个单一的类
			* 不单独设计常量类，而是哪个类用到常量，就把这个常量定义到这个类中。
		* 只包含静态方法不包含任何属性的 Utils 类，是彻彻底底的面向过程的编程风格。但这并不是说，我们就要杜绝使用 Utils 类了
	* 定义数据和方法分离的类：数据定义在一个类中，方法定义在另一个类中
		* web项目里面经常采用这种开发模式

* 面向过程编程及面向过程编程语言就真的无用武之地了吗？
	* 如果我们开发的是微小程序，或者是一个数据处理相关的代码，以算法为主，数据为辅，那脚本式的面向过程的编程风格就更适合一些

* `C语言如何实现面向对象的四大特性`
	* 继承：在派生类中维护一个基类对象的指针。这样派生类就可以访问基类对象的数据
	* 多态：在基类中维护一个派生类对象的指针。这样基类可以访问派生类对象的数据。
		* 对象如何销毁：使基类的删除函数指针指向派生类的删除函数。

## 理论五：接口vs抽象类的区别？如何用普通的类模拟抽象类和接口？

* 什么是抽象类和接口？区别在哪里？
	* 抽象类具有哪些特点
		* 抽象类不允许被实例化，只能被继承。也就是说，你不能 new 一个抽象类的对象出来
		* 抽象类可以包含属性和方法。方法既可以包含代码实现，也可以不包含代码实现。不包含代码实现的方法叫作抽象方法。
		* 子类继承抽象类，必须实现抽象类中的所有抽象方法。
	* 接口特点
		* 接口不能包含属性（也就是成员变量）。
		* 接口只能声明方法，方法不能包含代码实现。
		* 类实现接口的时候，必须实现接口中声明的所有方法。
	* 区别
		* 抽象类的 is-a 关系来说，接口表示一种 has-a 关系，表示具有某些功能。对于接口，有一个更加形象的叫法，那就是协议

* 抽象类和接口能解决什么编程问题？
	* 抽象类能解决什么实际的问题
		* 抽象类不能被实例化，只能被继承，抽象类是为代码复用而生的。
	* 接口能解决什么实际问题
		* 抽象类更多的是为了代码复用，而接口就更侧重于解耦
		* 接口实现了约定和实现相分离，可以降低代码间的耦合性，提高代码的可扩展性。

* C++中只有抽象类没有接口
	* 可以通过使用抽象类来模拟接口
		* 用接口的定义，理清何种程度的抽象类可以作为接口：1.没有成员变量 2. 只有方法声明，而没有方法实现 3.所有方法强制必须要被子类实现


* `如何决定该用抽象类还是接口？`
	* 实际上，判断的标准很简单。如果我们要表示一种 is-a 的关系，并且是为了解决代码复用的问题，我们就用抽象类；如果我们要表示一种 has-a 关系，并且是为了解决抽象而非代码复用的问题，那我们就可以使用接口。
	* 抽象类和接口的设计思路有本质上的区别，抽象类是合并代码共用产生的，但是接口其实是类对外的规范
	* 抽象类是一种自下而上的设计思路，先有子类的代码重复，然后再抽象成上层的父类（也就是抽象类）。而接口正好相反，它是一种自上而下的设计思路。我们在编程的时候，一般都是先设计接口，再去考虑具体的实现。     


## 理论六：为什么基于接口而非实现编程？有必要为每个类都定义接口吗？
* “基于接口而非实现编程”这条原则中的“接口”，可以理解为编程语言中的接口或者抽象类。
* 可以将接口和实现相分离，封装不稳定的实现，暴露稳定的接口。
* 上游系统面向接口而非实现编程，不依赖不稳定的实现细节，这样当实现发生变化的时候，上游系统的代码基本上不需要做改动，以此来降低耦合性，提高扩展性。

* `“基于接口而非实现编程”的原则，具体来讲，我们需要做到下面这 3 点。`
	* 函数的命名不能暴露任何实现细节
		* 这不仅仅是处于安全性的考虑。另一个因素是，如果你的命名中包含了这些细节，那你就没法对这个函数进行抽象了（因为你的命名已经是非常具体的了）
	* 封装具体的实现细节
		* 你需要考虑你的封装应该封装到哪个地步，如果太具体，外部调用的时候就会有非常高的耦合
	* 为实现类定义抽象的接口。具体的实现类都依赖统一的接口定义，遵从一致的上传功能协议。使用者依赖接口，而不是具体的实现类来编程。

* `某个功能只有一种实现方式，未来也不可能被其他实现方式替换，那我们就没有必要为其设计接口`

## 理论七：为何说要多用组合少用继承？如何决定该用组合还是继承？
* `组合优于继承，多用组合少用继承。`
* 为什么不推荐使用继承？
	* 继承层次过深、过复杂，也会影响到代码的可维护性
	* 如果情况过多，会导致类的继承层次越来越深，继承关系越来越复杂。
	* 类的封装特性，将父类的实现细节暴露给了子类。子类的实现依赖父类的实现，两者高度耦合，一旦父类代码修改，就会影响所有子类的逻辑。

* 组合相比继承有哪些优势？
	* `可以利用组合（composition）、接口、委托（delegation）三个技术手段，一块儿来解决刚刚继承存在的问题`
	* 继承的主要作用有3个：表示 is-a 关系，支持多态特性，代码复用
		* is-a 关系，我们可以通过组合和接口的 has-a 关系来替代
		* 多态特性我们可以利用接口来实现
		* 代码复用我们可以通过组合和委托来实现


* 如何判断该用组合还是继承？
	* `比较简单的时候用继承，复杂的情况下尽量使用组合！`
		* 类之间的继承结构稳定（不会轻易改变），继承层次比较浅（比如，最多有两层继承关系），继承关系不复杂，我们就可以大胆地使用继承。反之，系统越不稳定，继承层次很深，继承关系复杂，我们就尽量使用组合来替代继承。
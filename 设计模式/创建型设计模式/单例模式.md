# 单例模式

* 为什么要使用单例
	* 单例模式：一个类只允许创建一个对象或者实列，那么这个类就是单例类
	* 处理资源访问冲突：如写入日志，在多线程环境下，可能存在信息互相覆盖的情况
		* 加锁不可以解决写入日志互相覆盖的问题
			* 因为这种锁是对象锁，对象锁对同一个对象的执行有效，不同对象无效；在不同线程下，通过不同的对象调用执行函数，锁不会起作用。
			* `可以使用类级别的锁来解决问题`：C++中在类中定义锁为static实现类级别的锁
		* 单例模式实现，只允许创建一个对象，所有线程共享这个对象
	* 表示全局唯一类
		* 从业务概念上，如果有些数据在系统中只应保存一份，那就比较适合设计为单例类。

## 不推荐使用单例模式

* 单例对 OOP 特性的支持不友好
	* 单例对抽象、继承、多态都支持的不好
	* 单例的使用方式违背了基于接口而非实现编程原则
* 单例会隐藏类之间的依赖关系
	* 单例类不需要显示创建、不需要依赖参数传递，在函数中直接调用就可以了。如果代码比较复杂，这种调用关系就会非常隐蔽
* 单例对代码的扩展性不友好
	* `数据库连接池、线程池这类的资源池，最好还是不要设计成单例类`
		* 单例类在某些情况下会影响代码的扩展性、灵活性
* 单例对代码的可测试性不友好
* `单例不支持有参数的构造函数`
	* 比如我们创建一个连接池的单例对象，我们没法通过参数来指定连接池的大小
	* 解决方案
		* 在使用这个单例类的时候，要先调用 init() 方法，然后才能调用 getInstance() 方法
		* 将参数放到 getIntance() 方法中
			* `此方法存在问题，单例模式，类本身的初始化过程就只允许有一次，所以既然这样了，那么我建议就不要在getInstance中做参数的传递，直接以配置文件的形式，方法内部直接读取配置参数`
		* 将参数放到另外一个全局变量中，最值得推荐的方式

* 有何替代解决方案？
	* `为了保证全局唯一，除了使用单例，我们还可以用静态方法来实现`，但无法支持延迟加载
	* 可以将单例生成的对象，作为参数传递给函数，可以解决单例隐藏类之间依赖关系的问题
	* 要完全解决这些问题，我们可能要从根上，寻找其他方式来实现全局唯一类


## 如何设计实现一个集群环境下的分布式单例模式？

* 如何理解单例模式中的唯一性？
	* `一个类只允许创建唯一一个对象，对象的唯一性的作用范围`
		* 单例模式创建的对象是进程唯一的
		* 单例类在老进程中存在且只能存在一个对象，在新进程中也会存在且只能存在一个对象。而且，这两个对象并不是同一个对象

* **如何实现线程唯一的单例？**
	* “线程唯一”指的是线程内唯一，线程间可以不唯一
	* 通过一个 HashMap 来存储对象，其中 key 是线程 ID，value 是对象。这样我们就可以做到，不同的线程对应不同的对象，同一个线程只能对应一个对象

* **如何实现集群环境下的单例？**
	* 集群相当于多个进程构成的一个集合，“集群唯一”就相当于是进程内唯一、进程间也唯一。也就是说，不同的进程间共享同一个对象，不能创建同一个类的多个对象。
	* 需要把这个单例对象序列化并存储到外部共享存储区（比如文件）。为了保证任何时刻，在进程间都只有一份对象存在，一个进程在获取到对象之后，需要对对象加锁，避免其他进程再将其获取。在进程使用完这个对象之后，还需要显式地将对象从内存中删除，并且释放对对象的加锁。

* `如何实现一个多例模式？`
	* 多例”指的就是，一个类可以创建多个对象，但是个数是有限制的
	* 多例模式创建的对象都是同一个类的对象，而工厂模式创建的是不同子类的对象
	* 枚举类型也相当于多例模式，一个类型只能对应一个对象，一个类可以创建多个对象。


## 几种实现方式
* 懒汉式
	* 支持延迟加载：真正用到的时候，才去创建实例
	* 缺点在于，每次获取单例的时候，是加锁的，如果频繁使用，会影响调用效率

```c++
class Singleton{
public:
    static Singleton* getinstance()
    {
        Lock lock;
        if(m_instance == NULL)
        {
            m_instance = new Singleton();
        }
        return m_instance;
    }
private:
    Singleton();
    Singleton(const Singleton& other);
    static Singleton* m_instance; //静态成员变量
};

Singleton* Singleton::m_instance=nullptr; //静态成员需要先初始化
```

* 饿汉式
    * 在类加载的时候，静态实例已经创建并初始化好，这种创建过程是线程安全的，但这样的实现方式并不支持延迟加载。
	* 采用饿汉式实现方式，将耗时的初始化操作，提前到程序启动的时候完成，这样就能避免在程序运行的时候，再去初始化导致的性能问题。

```c++
class Singleton{
public:
    static Singleton* getinstance()
    {
        return instance;
    }
private:
    Singleton();
    static Singleton* p;
};

Singleton* Singleton::p = new Singleton();
Singleton* Singleton::Singleton()
{
    return p;
}
```

* 双重检测
	* 既支持延迟加载、又支持高并发的单例实现方式
    * 存在的问题
        * m_instance = new Singleton();分为三步执行
        * 分配了一个Singleton类型对象所需要的内存、分配的内存处构造Singleton类型的对象、把分配的内存的地址赋给指针m_instance。
        * 可能会认为这三个步骤是按顺序执行的，但实际上只能确定步骤1是最先执行的，步骤2，3却不一定。问题就出现在这。假如某个线程A在调用执行m_instance = new Singleton()的时候是按照1,3,2的顺序的，那么刚刚执行完步骤3给Singleton类型分配了内存（此时m_instance就不是nullptr了）就切换到了线程B，由于m_instance已经不是nullptr了，所以线程B会直接执行return m_instance得到一个对象，而这个对象并没有真正的被构造！！严重bug就这么发生了。
```c++
class Singleton{
public:
    static Singleton* getinstance()
    {
        if(m_instance == NULL)
        {
            Lock lock;
            if(m_instance == NULL)
            {
                m_instance = new Singleton();
            }
        }
        return m_instance;
    }
private:
    Singleton();
    Singleton(const Singleton& other);
    static Singleton* m_instance; //静态成员变量
};

Singleton* Singleton::m_instance=nullptr; //静态成员需要先初始化
```

* 静态内部类
    * 局部静态变量不仅只会初始化一次，而且还是线程安全的。
```c++
class Sing{
public:
    static Sing* getinstance();
private:
    Sing();
};

Sing* Sing::getinstance()
{
    static Sing obj;
    return &obj;
}
```